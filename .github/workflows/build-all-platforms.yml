name: Build All Platforms

# é…ç½®å·¥ä½œæµæƒé™
permissions:
  actions: write
  contents: write  # éœ€è¦å†™æƒé™æ¥åˆ›å»º Release

on:
  workflow_dispatch:
    inputs:
      platforms:
        description: 'Select platform to build'
        type: choice
        required: true
        default: 'all'
        options:
          - all
          - x86_64-linux
          - aarch64-linux
          - x86_64-windows

jobs:
  # æ£€æŸ¥è¦æ„å»ºçš„å¹³å°
  check-platforms:
    runs-on: ubuntu-latest
    outputs:
      selected-platform: ${{ steps.check.outputs.selected-platform }}
    steps:
      - name: Check platforms to build
        id: check
        run: |
          platforms="${{ github.event.inputs.platforms || 'all' }}"
          echo "Selected platform: $platforms"
          echo "selected-platform=$platforms" >> $GITHUB_OUTPUT

  # ç»Ÿä¸€æ„å»ºå’Œæ”¶é›†ä½œä¸š
  build-and-collect:
    needs: check-platforms
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Create artifacts directory
        run: mkdir -p artifacts
        
      - name: Trigger and wait for platform builds
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const workflows = [
              { file: 'build-x86_64-linux.yml', platform: 'x86_64-linux' },
              { file: 'build-aarch64-linux.yml', platform: 'aarch64-linux' },
              { file: 'build-x86_64-windows.yml', platform: 'x86_64-windows' }
            ];
            
            const selectedPlatform = '${{ needs.check-platforms.outputs.selected-platform }}';
            console.log(`Selected platform: ${selectedPlatform}`);
            
            // è¿‡æ»¤éœ€è¦æ„å»ºçš„å·¥ä½œæµ
            const workflowsToTrigger = workflows.filter(w => {
              if (selectedPlatform === 'all') return true;
              return selectedPlatform === w.platform;
            });
            
            console.log(`Will trigger ${workflowsToTrigger.length} workflows`);
            
            const triggeredRuns = [];
            
            // è§¦å‘å·¥ä½œæµå¹¶è®°å½•è¿è¡ŒID
            for (const workflow of workflowsToTrigger) {
              try {
                console.log(`Triggering ${workflow.file}...`);
                
                // å…ˆè·å–è§¦å‘å‰çš„æœ€æ–°è¿è¡ŒID
                const beforeRuns = await github.rest.actions.listWorkflowRuns({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: workflow.file,
                  per_page: 1
                });
                
                const beforeRunId = beforeRuns.data.workflow_runs.length > 0 ? beforeRuns.data.workflow_runs[0].id : null;
                
                const response = await github.rest.actions.createWorkflowDispatch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: workflow.file,
                  ref: context.ref
                });
                
                console.log(`Triggered ${workflow.file} successfully`);
                
                // ç­‰å¾…æ–°è¿è¡Œå‡ºç°
                let newRunId = null;
                let attempts = 0;
                const maxAttempts = 12; // æœ€å¤šç­‰å¾…60ç§’
                
                while (attempts < maxAttempts && !newRunId) {
                  await new Promise(resolve => setTimeout(resolve, 5000));
                  attempts++;
                  
                  const afterRuns = await github.rest.actions.listWorkflowRuns({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    workflow_id: workflow.file,
                    per_page: 5
                  });
                  
                  // æŸ¥æ‰¾æ–°çš„è¿è¡Œï¼ˆIDä¸åŒäºè§¦å‘å‰çš„è¿è¡Œï¼‰
                  for (const run of afterRuns.data.workflow_runs) {
                    if (run.id !== beforeRunId && run.status !== 'completed') {
                      newRunId = run.id;
                      break;
                    }
                  }
                }
                
                if (newRunId) {
                  triggeredRuns.push({
                    workflow: workflow.file,
                    platform: workflow.platform,
                    runId: newRunId
                  });
                  console.log(`Recorded new run ID ${newRunId} for ${workflow.file}`);
                } else {
                  console.log(`Failed to find new run for ${workflow.file}`);
                }
                
              } catch (error) {
                console.log(`Error triggering ${workflow.file}: ${error.message}`);
              }
            }
            
            console.log(`Triggered ${triggeredRuns.length} workflows, now waiting for completion...`);
            
            // ç­‰å¾…æ‰€æœ‰å·¥ä½œæµå®Œæˆ
            const maxWaitTime = 60 * 60 * 1000; // 1 hour
            const checkInterval = 30 * 1000; // 30 seconds
            const startTime = Date.now();
            
            while (Date.now() - startTime < maxWaitTime) {
              let allCompleted = true;
              
              for (const run of triggeredRuns) {
                if (run.completed) continue;
                
                try {
                  const runDetails = await github.rest.actions.getWorkflowRun({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    run_id: run.runId
                  });
                  
                  console.log(`${run.workflow} (${run.runId}): ${runDetails.data.status} - ${runDetails.data.conclusion}`);
                  
                  if (runDetails.data.status === 'completed') {
                    run.completed = true;
                    run.conclusion = runDetails.data.conclusion;
                    console.log(`âœ… ${run.workflow} completed with ${run.conclusion}`);
                  } else {
                    allCompleted = false;
                  }
                } catch (error) {
                  console.log(`Error checking ${run.workflow}: ${error.message}`);
                  allCompleted = false;
                }
              }
              
              if (allCompleted) {
                console.log('ğŸ‰ All workflows completed!');
                break;
              }
              
              console.log('â³ Waiting for workflows to complete...');
              await new Promise(resolve => setTimeout(resolve, checkInterval));
            }
            
            // æ£€æŸ¥æ˜¯å¦è¶…æ—¶
            if (Date.now() - startTime >= maxWaitTime) {
              throw new Error('â° Timeout waiting for workflows to complete');
            }
            
            // æ”¶é›†artifacts
            const artifactsList = [];
            
            for (const run of triggeredRuns) {
              if (run.conclusion === 'success') {
                try {
                  const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    run_id: run.runId
                  });
                  
                  for (const artifact of artifacts.data.artifacts) {
                    console.log(`Found artifact: ${artifact.name} from ${run.workflow}`);
                    artifactsList.push({
                      name: artifact.name,
                      workflow: run.workflow,
                      platform: run.platform,
                      download_url: artifact.archive_download_url,
                      size: artifact.size_in_bytes
                    });
                  }
                } catch (error) {
                  console.log(`Error collecting artifacts from ${run.workflow}: ${error.message}`);
                }
              } else {
                console.log(`âš ï¸ Skipping artifacts from ${run.workflow} (${run.conclusion})`);
              }
            }
            
            // ä¿å­˜artifactsä¿¡æ¯ï¼Œä¾›åç»­æ­¥éª¤ä½¿ç”¨
            fs.writeFileSync('artifacts-list.json', JSON.stringify(artifactsList, null, 2));
            console.log(`ğŸ“¦ Collected ${artifactsList.length} artifacts total`);
            
            return { triggeredRuns, artifactsList };

      - name: Download and extract build artifacts
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');
            const { execSync } = require('child_process');
            
            // è¯»å–æ„ä»¶åˆ—è¡¨
            const artifactsList = JSON.parse(fs.readFileSync('artifacts-list.json', 'utf8'));
            console.log(`ğŸ“¦ Processing ${artifactsList.length} artifacts`);
            
            // åˆ›å»ºå‘å¸ƒç›®å½•ç»“æ„
            const releaseDir = 'release-files';
            fs.mkdirSync(releaseDir, { recursive: true });
            
            const extractedFiles = [];
            
            // ä¸ºæ¯ä¸ªæ„ä»¶ä¸‹è½½å¹¶è§£å‹æ–‡ä»¶
            for (const artifact of artifactsList) {
              try {
                console.log(`â¬‡ï¸ Downloading artifact: ${artifact.name}`);
                
                // ä» download_url ä¸­æå– artifact ID
                const artifactId = parseInt(artifact.download_url.split('/artifacts/')[1].split('/zip')[0]);
                
                // ä¸‹è½½æ„ä»¶
                const download = await github.rest.actions.downloadArtifact({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  artifact_id: artifactId,
                  archive_format: 'zip',
                });
                
                // ä¿å­˜ä¸´æ—¶ zip æ–‡ä»¶
                const tempZipPath = path.join(releaseDir, `${artifact.name}.zip`);
                fs.writeFileSync(tempZipPath, Buffer.from(download.data));
                
                console.log(`âœ… Downloaded: ${artifact.name}.zip (${(download.data.byteLength / 1024).toFixed(1)} KB)`);
                
                // è§£å‹ zip æ–‡ä»¶
                console.log(`ğŸ“‚ Extracting ${artifact.name}.zip...`);
                
                try {
                  // ä½¿ç”¨ unzip å‘½ä»¤è§£å‹æ–‡ä»¶åˆ°å‘å¸ƒç›®å½•
                  execSync(`cd "${releaseDir}" && unzip -o "${artifact.name}.zip"`, { 
                    stdio: 'pipe',
                    encoding: 'utf8'
                  });
                  
                  // åˆ é™¤ä¸´æ—¶ zip æ–‡ä»¶
                  fs.unlinkSync(tempZipPath);
                  
                  // æŸ¥æ‰¾è§£å‹å‡ºçš„æ–‡ä»¶
                  const files = fs.readdirSync(releaseDir);
                  const newFiles = files.filter(f => !extractedFiles.includes(f) && f !== `${artifact.name}.zip`);
                  
                  extractedFiles.push(...newFiles);
                  
                  console.log(`âœ… Extracted files from ${artifact.name}: ${newFiles.join(', ')}`);
                  
                } catch (unzipError) {
                  console.log(`âŒ Failed to extract ${artifact.name}.zip: ${unzipError.message}`);
                  // å¦‚æœè§£å‹å¤±è´¥ï¼Œä¿ç•™ zip æ–‡ä»¶
                  console.log(`ğŸ“¦ Keeping original zip file: ${artifact.name}.zip`);
                }
                
              } catch (error) {
                console.log(`âŒ Failed to download ${artifact.name}: ${error.message}`);
              }
            }
            
            // åˆ—å‡ºæœ€ç»ˆçš„æ–‡ä»¶
            const finalFiles = fs.readdirSync(releaseDir);
            console.log(`ğŸ“ Final release files: ${finalFiles.join(', ')}`);

      - name: Create and clean release package
        run: |
          # åˆ›å»ºæœ€ç»ˆçš„å‘å¸ƒåŒ…
          TIMESTAMP=$(date -u +"%Y%m%d-%H%M%S")
          RELEASE_PACKAGE="ESurfingClient-Build-${TIMESTAMP}"

          echo "ğŸ“¦ Creating release package: ${RELEASE_PACKAGE}.zip"

          # åˆ›å»º zip åŒ…ï¼ˆä»å½“å‰ç›®å½•æ‰“åŒ… release-files ç›®å½•çš„å†…å®¹ï¼‰
          zip -r "${RELEASE_PACKAGE}.zip" release-files/*

          # æ¸…ç†å¹¶é‡æ–°è®¾ç½® release-files ç›®å½•
          rm -rf release-files
          mkdir release-files

          # å°† zip æ–‡ä»¶ç§»åˆ° release-files ç›®å½•
          mv "${RELEASE_PACKAGE}.zip" release-files/

          echo "âœ… Release package ready: release-files/${RELEASE_PACKAGE}.zip"

      - name: Generate release tag and name
        id: release_info
        run: |
          # ç”ŸæˆåŸºäºæ—¶é—´çš„æ ‡ç­¾å’Œå‘å¸ƒåç§°
          TIMESTAMP=$(date -u +"%Y%m%d-%H%M%S")
          RELEASE_TAG="build-${TIMESTAMP}"
          RELEASE_NAME="ESurfing Client Build - $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
          
          echo "release_tag=${RELEASE_TAG}" >> $GITHUB_OUTPUT
          echo "release_name=${RELEASE_NAME}" >> $GITHUB_OUTPUT
          
          echo "ğŸ·ï¸ Release tag: ${RELEASE_TAG}"
          echo "ğŸ“ Release name: ${RELEASE_NAME}"

      - name: Create GitHub Release
        id: create_release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.release_info.outputs.release_tag }}
          name: ${{ steps.release_info.outputs.release_name }}
          files: release-files/*
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}